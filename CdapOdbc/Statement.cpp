/*
* Copyright © 2015 Cask Data, Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License"); you may not
* use this file except in compliance with the License. You may obtain a copy of
* the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
* WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
* License for the specific language governing permissions and limitations under
* the License.
*/

#include "stdafx.h"
#include "Statement.h"
#include "Connection.h"
#include "String.h"
#include "Encoding.h"
#include "SchemasCommand.h"
#include "TablesCommand.h"
#include "TypesCommand.h"
#include "ColumnsCommand.h"
#include "SpecialColumnsCommand.h"
#include "QueryCommand.h"

namespace {
  /**
   * Gets real name of dataset.
   *
   * Hive table name is generated by adding either 'stream_' or 'dataset_' to sream/dataset name 
   * and converting all '-' to '_'. Unfortunately, it cannot be converted back without knowledge 
   * about the original name. So original names cached to map on SQLTables call. If SQLColumns called first
   * there is no cache so real name is guessed.
   * 
   * TODO: Fetch table list from server in SQLColumns if SQLTables not called first.
   */
  std::wstring getRealName(const std::wstring& streamName, const std::map<std::wstring, std::wstring>& tableNames) {
    auto& it = tableNames.find(streamName);
    if (it != tableNames.end()) {
      return it->second;
    } else {
      // Map is empty - try to guess
      if (streamName.find_first_of(L"stream_") == 0) {
        return streamName.substr(7);
      } else if (streamName.find_first_of(L"dataset_") == 0) {
        return streamName.substr(8);
      } else {
        // That's all we can do for now. 
        return streamName;
      }
    }
  }
}

void Cask::CdapOdbc::Statement::throwStateError() const {
  throw std::logic_error("Wrong statement state.");
}

void Cask::CdapOdbc::Statement::openQuery() {
  if (this->state != State::PREPARE) {
    this->throwStateError();
  }
  
  this->dataReader = this->command->executeReader();
  this->state = State::OPEN;
}

void Cask::CdapOdbc::Statement::executeInternal(const std::wstring& query) {
  if (this->state != State::INITIAL && this->state != State::PREPARE) {
    this->throwStateError();
  }

  if (this->state == State::INITIAL) {
    this->command = std::make_unique<QueryCommand>(this->connection, query);
    this->state = State::PREPARE;
  }

  if (this->state == State::PREPARE) {
    this->openQuery();
  }
}

void Cask::CdapOdbc::Statement::getColumnsInternal(const std::wstring& streamName) {
  if (this->state != State::INITIAL) {
    this->throwStateError();
  }

  auto realName = getRealName(streamName, this->tableNames);
  this->command = std::make_unique<ColumnsCommand>(this->connection, realName, streamName);
  this->state = State::PREPARE;

  this->openQuery();
}

void Cask::CdapOdbc::Statement::getTablesInternal(
  const std::wstring* catalog, 
  const std::wstring* schemaPattern, 
  const std::wstring* tableNamePattern, 
  const std::wstring* tableTypes) {
  if (this->state != State::INITIAL) {
    this->throwStateError();
  }

  this->command = std::make_unique<TablesCommand>(this->connection, this->tableNames);
  this->state = State::PREPARE;

  this->openQuery();
}

bool Cask::CdapOdbc::Statement::fetchInternal() {
  if (this->state != State::OPEN && this->state != State::FETCH) {
    this->throwStateError();
  }

  this->state = State::FETCH;
  if (this->dataReader->read()) {
    for (auto& binding : this->columnBindings) {
      this->dataReader->getColumnValue(binding);
    }

    return true;
  } else {
    this->state = State::CLOSED;
    return false;
  }
}

Cask::CdapOdbc::Statement::Statement(Connection* connection, SQLHSTMT handle)
  : state(State::INITIAL)
  , connection(connection)
  , handle(handle)
  , isAsync(connection->getIsAsync()) {
  assert(connection);
  assert(handle);
}

void Cask::CdapOdbc::Statement::addColumnBinding(const ColumnBinding& binding) {
  if (this->state == State::CLOSED) {
    this->throwStateError();
  }

  auto it = std::find_if(
    this->columnBindings.begin(),
    this->columnBindings.end(),
    [binding](auto& b) { return b.getColumnNumber() == binding.getColumnNumber(); });
  if (it != this->columnBindings.end()) {
    // Replace existing binding. 
    *it = binding;
  } else {
    // Add new binding. 
    this->columnBindings.push_back(binding);
  }
}

void Cask::CdapOdbc::Statement::removeColumnBinding(SQLUSMALLINT columnNumber) {
  auto it = std::find_if(
    this->columnBindings.begin(),
    this->columnBindings.end(),
    [columnNumber](auto& b) { return b.getColumnNumber() == columnNumber; }
  );
  if (it == this->columnBindings.end()) {
    throw std::invalid_argument("columnNumber");
  }

  this->columnBindings.erase(it);
}

void Cask::CdapOdbc::Statement::getSchemas(const std::wstring* catalog, const std::wstring* schemaPattern) {
  if (this->state != State::INITIAL) {
    this->throwStateError();
  }

  this->command = std::make_unique<SchemasCommand>(this->connection);
  this->state = State::PREPARE;

  this->openQuery();
}

void Cask::CdapOdbc::Statement::getTables(
  const std::wstring* catalog,
  const std::wstring* schemaPattern,
  const std::wstring* tableNamePattern,
  const std::wstring* tableTypes) {
  assert(!this->isAsync);
  this->getTablesInternal(catalog, schemaPattern, tableNamePattern, tableTypes);
}

bool Cask::CdapOdbc::Statement::getTablesAsync(
  const std::wstring* catalog, 
  const std::wstring* schemaPattern, 
  const std::wstring* tableNamePattern, 
  const std::wstring* tableTypes) {
  assert(this->isAsync);
  return this->runAsync(this->tablesTask, [this, catalog, schemaPattern, tableNamePattern, tableTypes]() {
    std::lock_guard<Connection> lock(*this->getConnection());
    this->getTablesInternal(catalog, schemaPattern, tableNamePattern, tableTypes);
  });
}

void Cask::CdapOdbc::Statement::getDataTypes() {
  if (this->state != State::INITIAL) {
    this->throwStateError();
  }

  this->command = std::make_unique<TypesCommand>(this->connection);
  this->state = State::PREPARE;

  this->openQuery();
}

void Cask::CdapOdbc::Statement::getColumns(const std::wstring& streamName) {
  assert(!this->isAsync);
  this->getColumnsInternal(streamName);
}

bool Cask::CdapOdbc::Statement::getColumnsAsync(const std::wstring& streamName) {
  assert(this->isAsync);
  return this->runAsync(this->columnsTask, [this, streamName]() {
    std::lock_guard<Connection> lock(*this->getConnection());
    this->getColumnsInternal(streamName);
  });
}

void Cask::CdapOdbc::Statement::getSpecialColumns() {
  if (this->state != State::INITIAL) {
    this->throwStateError();
  }

  this->command = std::make_unique<SpecialColumnsCommand>(this->connection);
  this->state = State::PREPARE;

  this->openQuery();
}

bool Cask::CdapOdbc::Statement::fetch() {
  assert(!this->isAsync);
  return this->fetchInternal();
}

bool Cask::CdapOdbc::Statement::fetchAsync(bool& hasData) {
  assert(this->isAsync);

  if (this->state != State::OPEN && this->state != State::FETCH) {
    this->throwStateError();
  }

  if (this->dataReader->canReadFast()) {
    hasData = this->fetchInternal();
    return true;
  } else {
    if (this->fetchTask) {
      if (this->fetchTask->is_done()) {
        hasData = this->fetchTask->get();
        this->fetchTask.reset();
        return true;
      } else {
        return false;
      }
    } else {
      this->fetchTask = std::make_unique<pplx::task<bool>>([this]() {
        std::lock_guard<Connection> lock(*this->getConnection());
        return this->fetchInternal();
      });
    
      return false;
    }
  }
}

void Cask::CdapOdbc::Statement::reset() {
  if (this->state != State::INITIAL) {
    this->command.reset();
    this->dataReader.reset();
    this->state = State::INITIAL;
  }
}

void Cask::CdapOdbc::Statement::unbindColumns() {
  if (this->state != State::INITIAL &&
    this->state != State::PREPARE &&
    this->state != State::OPEN) {
    this->throwStateError();
  }

  this->columnBindings.clear();
}

void Cask::CdapOdbc::Statement::resetParameters() {
  if (this->state != State::INITIAL) {
    this->throwStateError();
  }
}

void Cask::CdapOdbc::Statement::execute(const std::wstring& query) {
  assert(!this->isAsync);
  this->executeInternal(query);
}

bool Cask::CdapOdbc::Statement::executeAsync(const std::wstring& query) {
  assert(this->isAsync);
  return this->runAsync(this->executeTask, [this, query]() {
    std::lock_guard<Connection> lock(*this->getConnection());
    this->executeInternal(query);
  });
}

SQLSMALLINT Cask::CdapOdbc::Statement::getColumnCount() const {
  if (this->state != State::OPEN) {
    this->throwStateError();
  }

  return this->dataReader->getColumnCount();
}

std::unique_ptr<Cask::CdapOdbc::ColumnInfo> Cask::CdapOdbc::Statement::getColumnInfo(short columnNumber) const {
  return this->dataReader->getColumnInfo(columnNumber);
}

template<typename F>
bool Cask::CdapOdbc::Statement::runAsync(std::unique_ptr<pplx::task<void>>& task, F& function) {
  assert(this->isAsync);
  if (task) {
    if (task->is_done()) {
      // Throws all unhandled exceptions raised inside task body.
      task->get();
      task.reset();
      return true;
    } else {
      return false;
    }
  } else {
    task = std::make_unique<pplx::task<void>>(function);
    return false;
  }
}